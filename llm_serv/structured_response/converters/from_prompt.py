from typing import Any
from xml.etree import ElementTree as ET

from llm_serv.structured_response.utils import camel_to_snake, coerce_text_to_type


def from_prompt(self, xml_string: str) -> None:
    """
    Parse an LLM answer string, extract the XML section for the root element, and
    populate the instance dictionary according to the definition schema.
    
    Handles the XML format generated by to_prompt() method as described in README:
    - Root element is the class name (snake_case)
    - Simple fields contain text content
    - Dict fields contain child elements
    - List fields contain <li> elements with index attributes
    - Enum fields contain string values
    """
    if not self.definition:
        raise ValueError("Definition not initialized. Call from_basemodel first.")

    root_tag = camel_to_snake(self.class_name)
    # Extract substring between first <root_tag and last </root_tag>
    start_idx = xml_string.find(f"<{root_tag}")
    end_idx = xml_string.rfind(f"</{root_tag}>")
    if start_idx == -1 or end_idx == -1:
        raise ValueError(f"Root XML tags <{root_tag}> not found in LLM output")
    # Move end to include closing tag
    end_idx += len(f"</{root_tag}>")
    xml_sub = xml_string[start_idx:end_idx]

    # Ensure the opening tag is well-formed (strip attributes if any are present)
    try:
        root_element = ET.fromstring(xml_sub)
    except ET.ParseError as exc:
        raise ValueError(f"Invalid XML content: {exc}") from exc

    def parse_element(element: ET.Element, schema: Any) -> Any:
        """Parse an XML element according to its schema definition."""
        
        if isinstance(schema, dict) and schema.get("type") == "list":
            # List parsing from <li> children
            items: list[Any] = []
            for li in element.findall("li"):
                elem_schema = schema.get("elements")
                if isinstance(elem_schema, dict):
                    # Complex list item: dict with multiple fields
                    item: dict[str, Any] = {}
                    # Initialize all fields from schema to None first
                    for field_name in elem_schema.keys():
                        item[field_name] = None
                    # Then populate with actual values
                    for child in li:
                        if child.tag == "li":
                            continue
                        if child.tag is ET.Comment:
                            continue
                        field_schema = elem_schema.get(child.tag)
                        if field_schema is None:
                            # Skip unknown fields
                            continue
                        item[child.tag] = parse_element(child, field_schema)
                    items.append(item)
                else:
                    # Simple list item: direct text content
                    items.append(coerce_text_to_type(li.text or "", str(elem_schema)))
            return items

        if isinstance(schema, dict) and schema.get("type") == "dict":
            # Dict parsing: parse child elements according to elements schema
            obj: dict[str, Any] = {}
            elements_schema = schema.get("elements", {})
            if isinstance(elements_schema, dict):
                for field_name, field_schema in elements_schema.items():
                    child = element.find(field_name)
                    if child is None:
                        obj[field_name] = None
                        continue
                    obj[field_name] = parse_element(child, field_schema)
            return obj

        if isinstance(schema, dict) and "type" not in schema:
            # Legacy nested object: parse each child according to schema
            obj: dict[str, Any] = {}
            for field_name, field_schema in schema.items():
                child = element.find(field_name)
                if child is None:
                    obj[field_name] = None
                    continue
                obj[field_name] = parse_element(child, field_schema)
            return obj

        # Simple field (str, int, float, bool, enum)
        if not isinstance(schema, dict):
            # Handle case where schema is just a type string
            return coerce_text_to_type(element.text or "", str(schema))
            
        type_name = schema.get("type", "str")
        # For enum treat as str
        if type_name == "enum":
            return (element.text or "").strip()
        return coerce_text_to_type(element.text or "", type_name)

    # Parse root element fields
    self.instance = {}
    for field_name, schema in self.definition.items():
        child = root_element.find(field_name)
        if child is None:
            self.instance[field_name] = None
            continue
        self.instance[field_name] = parse_element(child, schema)

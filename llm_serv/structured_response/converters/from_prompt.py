from typing import Any
from xml.etree import ElementTree as ET

import sloppy_xml

from llm_serv.logger import logger
from llm_serv.structured_response.utils import camel_to_snake, coerce_text_to_type


def from_prompt(self, xml_string: str) -> "StructuredResponse":
    """
    Parse an LLM answer string, extract the XML section for the root element, and
    populate the instance dictionary according to the definition schema.
    
    Handles the XML format generated by to_prompt() method as described in README:
    - Root element is the class name (snake_case)
    - Simple fields contain text content
    - Dict fields contain child elements
    - List fields contain <li> elements with index attributes
    - Enum fields contain string values
    """
    if not self.definition:
        raise ValueError("Definition not initialized. Call from_basemodel first.")

    root_tag = camel_to_snake(self.class_name)
    # Extract substring between first <root_tag and last </root_tag>
    start_idx = xml_string.find(f"<{root_tag}")
    end_idx = xml_string.rfind(f"</{root_tag}>")
    if start_idx == -1 or end_idx == -1:
        raise ValueError(f"Root XML tags <{root_tag}> not found in LLM output")
    # Move end to include closing tag
    end_idx += len(f"</{root_tag}>")
    xml_sub = xml_string[start_idx:end_idx]

    # Ensure the opening tag is well-formed (strip attributes if any are present)
    try:
        #root_element = ET.fromstring(xml_sub)
        root_element = sloppy_xml.tree_parse(xml_sub)
    except ET.ParseError as exc:
        logger.error(f"Invalid XML content: {exc}")
        logger.error(f"XML content:\n{xml_sub}")
        raise ValueError(f"Invalid XML content: {exc}") from exc

    def parse_element(element: ET.Element, schema: Any) -> Any:
        """Parse an XML element according to its schema definition."""
        
        if isinstance(schema, dict) and schema.get("type") == "list":
            # List parsing from <li> children
            items: list[Any] = []
            for li in element.findall("li"):
                elem_schema = schema.get("elements")
                if isinstance(elem_schema, dict):
                    # Complex list item: dict with multiple fields
                    item: dict[str, Any] = {}
                    # Initialize all fields from schema to None first
                    for field_name in elem_schema.keys():
                        item[field_name] = None
                    # Then populate with actual values
                    for child in li:
                        if child.tag == "li":
                            continue
                        if child.tag is ET.Comment:
                            continue
                        field_schema = elem_schema.get(child.tag)
                        if field_schema is None:
                            # Skip unknown fields
                            continue
                        item[child.tag] = parse_element(child, field_schema)
                    items.append(item)
                else:
                    # Simple list item: direct text content
                    items.append(coerce_text_to_type(li.text or "", str(elem_schema)))
            return items

        if isinstance(schema, dict) and schema.get("type") == "dict":
            # Dict parsing: parse child elements according to elements schema
            obj: dict[str, Any] = {}
            elements_schema = schema.get("elements", {})
            if isinstance(elements_schema, dict):
                for field_name, field_schema in elements_schema.items():
                    child = element.find(field_name)
                    if child is None:
                        obj[field_name] = None
                        continue
                    obj[field_name] = parse_element(child, field_schema)
            return obj

        if isinstance(schema, dict) and "type" not in schema:
            # Legacy nested object: parse each child according to schema
            obj: dict[str, Any] = {}
            for field_name, field_schema in schema.items():
                child = element.find(field_name)
                if child is None:
                    obj[field_name] = None
                    continue
                obj[field_name] = parse_element(child, field_schema)
            return obj

        # Simple field (str, int, float, bool, enum)
        if not isinstance(schema, dict):
            # Handle case where schema is just a type string
            return coerce_text_to_type(element.text or "", str(schema))
            
        type_name = schema.get("type", "str")
        # For enum treat as str
        if type_name == "enum":
            return (element.text or "").strip()
        return coerce_text_to_type(element.text or "", type_name)

    # Parse root element fields
    self.instance = {}
    for field_name, schema in self.definition.items():
        child = root_element.find(field_name)
        if child is None:
            self.instance[field_name] = None
            continue
        self.instance[field_name] = parse_element(child, schema)

    return self

def _preprocess_xml(xml_string: str) -> str:
    """
    Preprocess the XML string to remove any comments and other non-essential content.
    """
    return xml_string


if __name__ == "__main__":
    xml_string = """
    <query_generation_response>
    <vector_store_queries type='list' elements='str' description='The queries used to retrieve the statements from the vector store'>
        <li index='0'>Corporate strategy for renewable generation expansion and portfolio diversification</li>
        <li index='1'>Utility-scale wind and solar capacity addition targets through 2030</li>
        <li index='2'>Pipeline of greenfield projects with development, permitting, construction timelines</li>
        <li index='3'>Plan for grid interconnection, transmission upgrades, curtailment mitigation</li>
        <li index='4'>Equipment sourcing and EPC strategy for wind turbines and PV modules</li>
        <li index='5'>Capital allocation and financing for clean generation buildout, tax credits</li>
        <li index='6'>Operations, maintenance, asset management plans for new clean generation</li>
        <li index='7'>Land acquisition, community engagement, environmental impact for new projects</li>
        <li index='8'>Replacement of fossil units with new zero-carbon generation capacity</li>
        <li index='9'>Hydroelectric and geothermal development strategy within clean energy portfolio</li>
    </vector_store_queries>
    <bm25_queries type='list' elements='str' description='The queries used to retrieve the statements from the bm25 model'>
        <li index='0'>renewables expansion strategy, corporate roadmap, growth targets, portfolio diversification, utility sector</li>
        <li index='1'>utility-scale wind MW targets, solar PV additions, 2025 milestones, 2030 goals</li>
        <li index='2'>greenfield pipeline, interconnection queue, site control, permits, NEPA, development stages</li>
        <li index='3'>interconnection agreements, transmission capacity, congestion, curtailment risk, ERCOT, PJM, CAISO</li>
        <li index='4'>turbine suppliers, photovoltaic module procurement, trackers, inverters, EPC contracts, supply chain</li>
        <li index='5'>capex, project finance, PTC, ITC, transferability, Inflation Reduction Act, tax equity</li>
        <li index='6'>O&M, availability, capacity factor, warranties, service agreements, SCADA, predictive maintenance</li>
        <li index='7'>site leasing, easements, wildlife studies, environmental impact assessment, community benefits, local hiring</li>
        <li index='8'>coal retirements, gas plant conversion, replacement capacity, decarbonization pathway, emissions reduction targets</li>
        <li index='9'>hydro expansion, pumped storage, geothermal wells, binary cycle, resource assessment, exploration</li>
    </bm25_queries>
</query_generation_response>
    """
    print(_preprocess_xml(xml_string))

    

    output = sloppy_xml.tree_parse(xml_string)
    print(output)